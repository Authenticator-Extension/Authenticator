import Vue from 'vue';
import ImportView from './components/Import.vue';
import { loadI18nMessages } from './store/i18n';

import { Encryption } from './models/encryption';
import { EntryStorage } from './models/storage';
import * as CryptoJS from 'crypto-js';

async function init() {
  // i18n
  Vue.prototype.i18n = await loadI18nMessages();

  // Load entries to global
  const encryption = new Encryption(await getCachedPassphrase());
  Vue.prototype.$entries = await EntryStorage.get(encryption);
  Vue.prototype.$encryption = encryption;

  const instance = new Vue({
    render: h => h(ImportView),
  }).$mount('#import');

  // Set title
  try {
    document.title = instance.i18n.extName;
  } catch (e) {
    console.error(e);
  }
}

init();

function getCachedPassphrase() {
  return new Promise(
    (resolve: (value: string) => void, reject: (reason: Error) => void) => {
      const cookie = document.cookie;
      const cookieMatch = cookie
        ? document.cookie.match(/passphrase=([^;]*)/)
        : null;
      const cachedPassphrase =
        cookieMatch && cookieMatch.length > 1 ? cookieMatch[1] : null;
      if (cachedPassphrase) {
        return resolve(cachedPassphrase);
      }

      chrome.runtime.sendMessage(
        { action: 'passphrase' },
        (passphrase: string) => {
          return resolve(passphrase);
        }
      );
    }
  );
}

export function decryptBackupData(
  backupData: { [hash: string]: OTPStorage },
  passphrase: string | null
) {
  const decryptedbackupData: { [hash: string]: OTPStorage } = {};
  for (const hash of Object.keys(backupData)) {
    if (typeof backupData[hash] !== 'object') {
      continue;
    }
    if (!backupData[hash].secret) {
      continue;
    }
    if (backupData[hash].encrypted && !passphrase) {
      continue;
    }
    if (backupData[hash].encrypted && passphrase) {
      try {
        backupData[hash].secret = CryptoJS.AES.decrypt(
          backupData[hash].secret,
          passphrase
        ).toString(CryptoJS.enc.Utf8);
        backupData[hash].encrypted = false;
      } catch (error) {
        continue;
      }
    }
    // backupData[hash].secret may be empty after decrypt with wrong
    // passphrase
    if (!backupData[hash].secret) {
      continue;
    }
    decryptedbackupData[hash] = backupData[hash];
  }
  return decryptedbackupData;
}

export function getEntryDataFromOTPAuthPerLine(importCode: string) {
  const lines = importCode.split('\n');
  const exportData: { [hash: string]: OTPStorage } = {};
  for (let item of lines) {
    item = item.trim();
    if (!item.startsWith('otpauth:')) {
      continue;
    }

    let uri = item.split('otpauth://')[1];
    let type = uri.substr(0, 4).toLowerCase();
    uri = uri.substr(5);
    let label = uri.split('?')[0];
    const parameterPart = uri.split('?')[1];
    if (!parameterPart) {
      continue;
    } else {
      let account = '';
      let secret = '';
      let issuer = '';
      let period: number | undefined = undefined;

      try {
        label = decodeURIComponent(label);
      } catch (error) {
        console.error(error);
      }
      if (label.indexOf(':') !== -1) {
        issuer = label.split(':')[0];
        account = label.split(':')[1];
      } else {
        account = label;
      }
      const parameters = parameterPart.split('&');
      parameters.forEach(item => {
        const parameter = item.split('=');
        if (parameter[0].toLowerCase() === 'secret') {
          secret = parameter[1];
        } else if (parameter[0].toLowerCase() === 'issuer') {
          try {
            issuer = decodeURIComponent(parameter[1]);
          } catch {
            issuer = parameter[1];
          }
          issuer = issuer.replace(/\+/g, ' ');
        } else if (parameter[0].toLowerCase() === 'counter') {
          let counter = Number(parameter[1]);
          counter = isNaN(counter) || counter < 0 ? 0 : counter;
        } else if (parameter[0].toLowerCase() === 'period') {
          period = Number(parameter[1]);
          period =
            isNaN(period) || period < 0 || period > 60 || 60 % period !== 0
              ? undefined
              : period;
        }
      });

      if (!secret) {
        continue;
      } else if (
        !/^[0-9a-f]+$/i.test(secret) &&
        !/^[2-7a-z]+=*$/i.test(secret)
      ) {
        continue;
      } else {
        const hash = CryptoJS.MD5(secret).toString();
        if (
          !/^[2-7a-z]+=*$/i.test(secret) &&
          /^[0-9a-f]+$/i.test(secret) &&
          type === 'totp'
        ) {
          type = 'hex';
        } else if (
          !/^[2-7a-z]+=*$/i.test(secret) &&
          /^[0-9a-f]+$/i.test(secret) &&
          type === 'hotp'
        ) {
          type = 'hhex';
        }

        exportData[hash] = {
          account,
          hash,
          issuer,
          secret,
          type,
          encrypted: false,
          index: 0,
          counter: 0,
        };
        if (period) {
          exportData[hash].period = period;
        }
      }
    }
  }
  return exportData;
}
